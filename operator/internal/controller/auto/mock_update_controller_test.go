// Code generated by MockGen. DO NOT EDIT.
// Source: internal/controller/auto/update_controller.go
//
// Generated by this command:
//
//	mockgen -source internal/controller/auto/update_controller.go -package controller -typed -destination internal/controller/auto/mock_update_controller_test.go
//

// Package controller is a generated GoMock package.
package controller

import (
	context "context"
	reflect "reflect"

	proto "github.com/pulumi/pulumi-kubernetes-operator/v2/agent/pkg/proto"
	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
	metadata "google.golang.org/grpc/metadata"
	client "sigs.k8s.io/controller-runtime/pkg/client"
)

// Mockupper is a mock of upper interface.
type Mockupper struct {
	ctrl     *gomock.Controller
	recorder *MockupperMockRecorder
}

// MockupperMockRecorder is the mock recorder for Mockupper.
type MockupperMockRecorder struct {
	mock *Mockupper
}

// NewMockupper creates a new mock instance.
func NewMockupper(ctrl *gomock.Controller) *Mockupper {
	mock := &Mockupper{ctrl: ctrl}
	mock.recorder = &MockupperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockupper) EXPECT() *MockupperMockRecorder {
	return m.recorder
}

// Up mocks base method.
func (m *Mockupper) Up(ctx context.Context, in *proto.UpRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[proto.UpStream], error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Up", varargs...)
	ret0, _ := ret[0].(grpc.ServerStreamingClient[proto.UpStream])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Up indicates an expected call of Up.
func (mr *MockupperMockRecorder) Up(ctx, in any, opts ...any) *MockupperUpCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Up", reflect.TypeOf((*Mockupper)(nil).Up), varargs...)
	return &MockupperUpCall{Call: call}
}

// MockupperUpCall wrap *gomock.Call
type MockupperUpCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockupperUpCall) Return(arg0 grpc.ServerStreamingClient[proto.UpStream], arg1 error) *MockupperUpCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockupperUpCall) Do(f func(context.Context, *proto.UpRequest, ...grpc.CallOption) (grpc.ServerStreamingClient[proto.UpStream], error)) *MockupperUpCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockupperUpCall) DoAndReturn(f func(context.Context, *proto.UpRequest, ...grpc.CallOption) (grpc.ServerStreamingClient[proto.UpStream], error)) *MockupperUpCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockrecver is a mock of recver interface.
type Mockrecver[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockrecverMockRecorder[T]
}

// MockrecverMockRecorder is the mock recorder for Mockrecver.
type MockrecverMockRecorder[T any] struct {
	mock *Mockrecver[T]
}

// NewMockrecver creates a new mock instance.
func NewMockrecver[T any](ctrl *gomock.Controller) *Mockrecver[T] {
	mock := &Mockrecver[T]{ctrl: ctrl}
	mock.recorder = &MockrecverMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockrecver[T]) EXPECT() *MockrecverMockRecorder[T] {
	return m.recorder
}

// CloseSend mocks base method.
func (m *Mockrecver[T]) CloseSend() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloseSend")
	ret0, _ := ret[0].(error)
	return ret0
}

// CloseSend indicates an expected call of CloseSend.
func (mr *MockrecverMockRecorder[T]) CloseSend() *MockrecverCloseSendCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseSend", reflect.TypeOf((*Mockrecver[T])(nil).CloseSend))
	return &MockrecverCloseSendCall[T]{Call: call}
}

// MockrecverCloseSendCall wrap *gomock.Call
type MockrecverCloseSendCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrecverCloseSendCall[T]) Return(arg0 error) *MockrecverCloseSendCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrecverCloseSendCall[T]) Do(f func() error) *MockrecverCloseSendCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrecverCloseSendCall[T]) DoAndReturn(f func() error) *MockrecverCloseSendCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Context mocks base method.
func (m *Mockrecver[T]) Context() context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Context")
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// Context indicates an expected call of Context.
func (mr *MockrecverMockRecorder[T]) Context() *MockrecverContextCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Context", reflect.TypeOf((*Mockrecver[T])(nil).Context))
	return &MockrecverContextCall[T]{Call: call}
}

// MockrecverContextCall wrap *gomock.Call
type MockrecverContextCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrecverContextCall[T]) Return(arg0 context.Context) *MockrecverContextCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrecverContextCall[T]) Do(f func() context.Context) *MockrecverContextCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrecverContextCall[T]) DoAndReturn(f func() context.Context) *MockrecverContextCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Header mocks base method.
func (m *Mockrecver[T]) Header() (metadata.MD, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Header")
	ret0, _ := ret[0].(metadata.MD)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Header indicates an expected call of Header.
func (mr *MockrecverMockRecorder[T]) Header() *MockrecverHeaderCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Header", reflect.TypeOf((*Mockrecver[T])(nil).Header))
	return &MockrecverHeaderCall[T]{Call: call}
}

// MockrecverHeaderCall wrap *gomock.Call
type MockrecverHeaderCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrecverHeaderCall[T]) Return(arg0 metadata.MD, arg1 error) *MockrecverHeaderCall[T] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrecverHeaderCall[T]) Do(f func() (metadata.MD, error)) *MockrecverHeaderCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrecverHeaderCall[T]) DoAndReturn(f func() (metadata.MD, error)) *MockrecverHeaderCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Recv mocks base method.
func (m *Mockrecver[T]) Recv() (*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Recv")
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Recv indicates an expected call of Recv.
func (mr *MockrecverMockRecorder[T]) Recv() *MockrecverRecvCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Recv", reflect.TypeOf((*Mockrecver[T])(nil).Recv))
	return &MockrecverRecvCall[T]{Call: call}
}

// MockrecverRecvCall wrap *gomock.Call
type MockrecverRecvCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrecverRecvCall[T]) Return(arg0 *T, arg1 error) *MockrecverRecvCall[T] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrecverRecvCall[T]) Do(f func() (*T, error)) *MockrecverRecvCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrecverRecvCall[T]) DoAndReturn(f func() (*T, error)) *MockrecverRecvCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RecvMsg mocks base method.
func (m_2 *Mockrecver[T]) RecvMsg(m any) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "RecvMsg", m)
	ret0, _ := ret[0].(error)
	return ret0
}

// RecvMsg indicates an expected call of RecvMsg.
func (mr *MockrecverMockRecorder[T]) RecvMsg(m any) *MockrecverRecvMsgCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecvMsg", reflect.TypeOf((*Mockrecver[T])(nil).RecvMsg), m)
	return &MockrecverRecvMsgCall[T]{Call: call}
}

// MockrecverRecvMsgCall wrap *gomock.Call
type MockrecverRecvMsgCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrecverRecvMsgCall[T]) Return(arg0 error) *MockrecverRecvMsgCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrecverRecvMsgCall[T]) Do(f func(any) error) *MockrecverRecvMsgCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrecverRecvMsgCall[T]) DoAndReturn(f func(any) error) *MockrecverRecvMsgCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendMsg mocks base method.
func (m_2 *Mockrecver[T]) SendMsg(m any) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "SendMsg", m)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendMsg indicates an expected call of SendMsg.
func (mr *MockrecverMockRecorder[T]) SendMsg(m any) *MockrecverSendMsgCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMsg", reflect.TypeOf((*Mockrecver[T])(nil).SendMsg), m)
	return &MockrecverSendMsgCall[T]{Call: call}
}

// MockrecverSendMsgCall wrap *gomock.Call
type MockrecverSendMsgCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrecverSendMsgCall[T]) Return(arg0 error) *MockrecverSendMsgCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrecverSendMsgCall[T]) Do(f func(any) error) *MockrecverSendMsgCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrecverSendMsgCall[T]) DoAndReturn(f func(any) error) *MockrecverSendMsgCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Trailer mocks base method.
func (m *Mockrecver[T]) Trailer() metadata.MD {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Trailer")
	ret0, _ := ret[0].(metadata.MD)
	return ret0
}

// Trailer indicates an expected call of Trailer.
func (mr *MockrecverMockRecorder[T]) Trailer() *MockrecverTrailerCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trailer", reflect.TypeOf((*Mockrecver[T])(nil).Trailer))
	return &MockrecverTrailerCall[T]{Call: call}
}

// MockrecverTrailerCall wrap *gomock.Call
type MockrecverTrailerCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrecverTrailerCall[T]) Return(arg0 metadata.MD) *MockrecverTrailerCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrecverTrailerCall[T]) Do(f func() metadata.MD) *MockrecverTrailerCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrecverTrailerCall[T]) DoAndReturn(f func() metadata.MD) *MockrecverTrailerCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockcreator is a mock of creator interface.
type Mockcreator struct {
	ctrl     *gomock.Controller
	recorder *MockcreatorMockRecorder
}

// MockcreatorMockRecorder is the mock recorder for Mockcreator.
type MockcreatorMockRecorder struct {
	mock *Mockcreator
}

// NewMockcreator creates a new mock instance.
func NewMockcreator(ctrl *gomock.Controller) *Mockcreator {
	mock := &Mockcreator{ctrl: ctrl}
	mock.recorder = &MockcreatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockcreator) EXPECT() *MockcreatorMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *Mockcreator) Create(ctx context.Context, obj client.Object, opts ...client.CreateOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Create", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockcreatorMockRecorder) Create(ctx, obj any, opts ...any) *MockcreatorCreateCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, obj}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*Mockcreator)(nil).Create), varargs...)
	return &MockcreatorCreateCall{Call: call}
}

// MockcreatorCreateCall wrap *gomock.Call
type MockcreatorCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockcreatorCreateCall) Return(arg0 error) *MockcreatorCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockcreatorCreateCall) Do(f func(context.Context, client.Object, ...client.CreateOption) error) *MockcreatorCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockcreatorCreateCall) DoAndReturn(f func(context.Context, client.Object, ...client.CreateOption) error) *MockcreatorCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
